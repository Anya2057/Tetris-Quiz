<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Neon Tetris Quiz Pro</title>
    <style>
        :root {
            --bg-color: #020617;
            --panel-bg: rgba(15, 23, 42, 0.85);
            --accent-glow: #38bdf8;
            --text-main: #e2e8f0;
            --text-muted: #94a3b8;
            --danger: #f43f5e;
            --btn-neutral: #334155;
            --font-family: 'Segoe UI', system-ui, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: var(--font-family);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        /* –§–æ–Ω —Å–æ –∑–≤–µ–∑–¥–∞–º–∏ */
        canvas#bg-stars {
            position: fixed;
            top: 0; left: 0;
            z-index: -1;
        }

        /* –ì–ª–∞–≤–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä */
        #game-wrapper {
            display: flex;
            gap: 20px;
            padding: 20px;
            background: var(--panel-bg);
            border-radius: 24px;
            box-shadow: 0 0 60px rgba(0, 0, 0, 0.8), inset 0 0 0 1px rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            position: relative;
        }

        /* –≠—Ñ—Ñ–µ–∫—Ç —Ç—Ä—è—Å–∫–∏ (Shake) */
        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* –ö–∞–Ω–≤–∞—Å –∏–≥—Ä—ã */
        canvas#tetris {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.05);
            box-shadow: inset 0 0 30px rgba(0,0,0,0.5);
        }

        /* –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å */
        .side-panel {
            width: 200px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel-box {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 16px;
            padding: 15px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .label {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-muted);
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .value {
            font-size: 24px;
            font-weight: 800;
            color: var(--accent-glow);
            text-shadow: 0 0 15px rgba(56, 189, 248, 0.5);
        }

        /* –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: auto;
        }

        .key-btn {
            background: var(--btn-neutral);
            border-radius: 8px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-bottom: 3px solid #1e293b;
            transition: all 0.1s;
        }
        .key-btn:active { transform: translateY(2px); border-bottom-width: 0; }
        .key-btn span { font-size: 16px; color: #fff; }

        /* –ö–Ω–æ–ø–∫–∏ –º–µ–Ω—é */
        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .btn {
            border: none;
            padding: 12px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 13px;
            cursor: pointer;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: filter 0.2s, transform 0.2s;
        }
        .btn:hover { filter: brightness(1.15); transform: translateY(-1px); }
        
        .btn-menu { background: var(--btn-neutral); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .btn-exit { background: var(--danger); box-shadow: 0 4px 15px rgba(244, 63, 94, 0.3); }
        .btn-primary { background: var(--accent-glow); color: #0f172a; box-shadow: 0 0 20px rgba(56, 189, 248, 0.4); }

        /* –û–≤–µ—Ä–ª–µ–∏ (–ú–µ–Ω—é, –ö–≤–∏–∑, –†–µ–∑—É–ª—å—Ç–∞—Ç) */
        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(2, 6, 23, 0.96);
            border-radius: 24px;
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .overlay.active { opacity: 1; pointer-events: all; }

        h1 { margin: 0 0 10px 0; font-size: 32px; color: var(--accent-glow); text-shadow: 0 0 20px rgba(56, 189, 248, 0.6); }
        h2 { color: #fff; margin-bottom: 20px; font-weight: 600; }
        p { color: var(--text-muted); margin-bottom: 30px; font-size: 14px; }

        /* –°—Ç–∏–ª–∏ –¥–ª—è –ö–≤–∏–∑–∞ */
        .quiz-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .quiz-opt {
            background: #1e293b;
            border: 1px solid #334155;
            padding: 15px;
            border-radius: 12px;
            color: #fff;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s;
        }
        .quiz-opt:hover { background: #334155; border-color: var(--accent-glow); }

        .hidden { display: none !important; }
    </style>
</head>
<body>

<canvas id="bg-stars"></canvas>

<div id="game-wrapper">
    <canvas id="tetris" width="300" height="600"></canvas>

    <div class="side-panel">
        <div class="panel-box">
            <div class="label">–°–õ–ï–î–£–Æ–©–ê–Ø</div>
            <canvas id="next" width="80" height="60"></canvas>
        </div>

        <div class="panel-box">
            <div class="label">–í–†–ï–ú–Ø</div>
            <div id="time-val" class="value">05:00</div>
        </div>

        <div class="panel-box">
            <div class="label">–û–ß–ö–ò</div>
            <div id="score-val" class="value">0</div>
        </div>

        <div style="flex-grow: 1;"></div>

        <div class="controls-grid">
            <div></div>
            <div class="key-btn" onclick="input(38)"><span>‚Üª</span></div>
            <div></div>
            <div class="key-btn" onclick="input(37)"><span>‚Üê</span></div>
            <div class="key-btn" onclick="input(40)"><span>‚Üì</span></div>
            <div class="key-btn" onclick="input(39)"><span>‚Üí</span></div>
        </div>

        <div class="btn-group">
            <button class="btn btn-menu" onclick="resetToMenu()">–ú–µ–Ω—é</button>
            <button class="btn btn-exit" onclick="endGame(false, true)">–í—ã–π—Ç–∏</button>
        </div>
    </div>

    <div id="menu-overlay" class="overlay active">
        <h1>NEON TETRIS</h1>
        <p>–û–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è –≥–æ–ª–æ–≤–æ–ª–æ–º–∫–∞</p>
        <button class="btn btn-primary" style="width: 200px; padding: 16px;" onclick="startGame('timer')">‚è± –°–ü–†–ò–ù–¢ (5 –ú–ò–ù)</button>
        <button class="btn btn-menu" style="width: 200px; margin-top: 10px; background: transparent; border: 1px solid #334155;" onclick="startGame('infinite')">‚ôæ –ë–ï–°–ö–û–ù–ï–ß–ù–û</button>
    </div>

    <div id="quiz-overlay" class="overlay">
        <div style="width: 100%; text-align: left;">
            <div class="label" style="margin-bottom: 10px;">–í–û–ü–†–û–°</div>
            <h2 id="q-text" style="margin-top: 0; font-size: 20px; line-height: 1.4;">–¢–µ–∫—Å—Ç –≤–æ–ø—Ä–æ—Å–∞?</h2>
        </div>
        <div id="q-options" class="quiz-container"></div>
    </div>

    <div id="result-overlay" class="overlay">
        <h1 id="res-title">–ü–û–ë–ï–î–ê!</h1>
        <p id="res-desc">–û—Ç–ª–∏—á–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç</p>
        <div class="panel-box" style="width: 80%; margin-bottom: 20px;">
            <div class="label">–ò–¢–û–ì–û–í–´–ô –°–ß–ï–¢</div>
            <div id="res-score" class="value">0</div>
        </div>
        <button class="btn btn-primary" style="width: 160px;" onclick="resetToMenu()">–í –ú–ï–ù–Æ</button>
    </div>
</div>

<script>
/* --- 1. –ê–£–î–ò–û –î–í–ò–ñ–û–ö (SFX) --- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playTone(freq, type, dur, vol=0.1) {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + dur);
}

const SFX = {
    move: () => playTone(300, 'sine', 0.05, 0.05),
    rotate: () => playTone(400, 'triangle', 0.1, 0.05),
    drop: () => playTone(150, 'sawtooth', 0.1, 0.1),
    clear: () => { playTone(600, 'sine', 0.1, 0.2); setTimeout(()=>playTone(800, 'sine', 0.2, 0.2), 100); },
    error: () => { playTone(150, 'sawtooth', 0.3, 0.3); setTimeout(()=>playTone(100, 'sawtooth', 0.3, 0.3), 150); },
    win: () => { [523, 659, 783, 1046].forEach((f,i) => setTimeout(()=>playTone(f, 'square', 0.3, 0.1), i*120)); }
};

/* --- 2. –ì–†–ê–§–ò–ö–ê: –ó–í–ï–ó–î–´ –ò –ù–ï–û–ù --- */
const cvs = document.getElementById('tetris');
const ctx = cvs.getContext('2d');
const nextCvs = document.getElementById('next');
const nextCtx = nextCvs.getContext('2d');

// –¶–≤–µ—Ç–∞ –±–ª–æ–∫–æ–≤ (–ù–µ–æ–Ω–æ–≤–∞—è –ø–∞–ª–∏—Ç—Ä–∞)
const COLORS = [
    null,
    '#ff0055', // Z - Red/Pink
    '#00ff99', // S - Green
    '#cc00ff', // T - Purple
    '#ffff00', // O - Yellow
    '#00ccff', // I - Cyan
    '#ff6600', // L - Orange
    '#0066ff'  // J - Blue
];

// –§–æ–Ω: –ó–≤–µ–∑–¥—ã (–ü–ª–∞–≤–Ω—ã–µ –∏ –º–µ–¥–ª–µ–Ω–Ω—ã–µ)
const bgCvs = document.getElementById('bg-stars');
const bgCtx = bgCvs.getContext('2d');
let stars = [];

function initStars() {
    bgCvs.width = window.innerWidth;
    bgCvs.height = window.innerHeight;
    stars = [];
    for(let i=0; i<150; i++) {
        stars.push({
            x: Math.random() * bgCvs.width,
            y: Math.random() * bgCvs.height,
            size: Math.random() * 1.5,
            speed: Math.random() * 0.3 + 0.1, // –ú–µ–¥–ª–µ–Ω–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
            alpha: Math.random()
        });
    }
}
window.onresize = initStars;
initStars();

function drawBackground() {
    bgCtx.clearRect(0,0, bgCvs.width, bgCvs.height);
    bgCtx.fillStyle = '#fff';
    
    stars.forEach(s => {
        bgCtx.globalAlpha = s.alpha * 0.7; // –õ–µ–≥–∫–∞—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å
        bgCtx.beginPath();
        bgCtx.arc(s.x, s.y, s.size, 0, Math.PI*2);
        bgCtx.fill();
        
        // –î–≤–∏–∂–µ–Ω–∏–µ –≤–Ω–∏–∑
        s.y += s.speed;
        if(s.y > bgCvs.height) {
            s.y = 0;
            s.x = Math.random() * bgCvs.width;
        }
    });
    bgCtx.globalAlpha = 1;
    
    // –†–∏—Å—É–µ–º —Ñ–µ–π–µ—Ä–≤–µ—Ä–∫–∏, –µ—Å–ª–∏ –µ—Å—Ç—å
    updateFireworks();
    
    requestAnimationFrame(drawBackground);
}
drawBackground();

// –§–µ–π–µ—Ä–≤–µ—Ä–∫–∏ (–ß–∞—Å—Ç–∏—Ü—ã)
let particles = [];
function createFirework(x, y, color) {
    for(let i=0; i<25; i++) {
        const ang = Math.random() * Math.PI * 2;
        const spd = Math.random() * 4 + 1;
        particles.push({
            x, y, color,
            vx: Math.cos(ang) * spd,
            vy: Math.sin(ang) * spd,
            life: 1.0
        });
    }
}
function updateFireworks() {
    for(let i=particles.length-1; i>=0; i--) {
        const p = particles[i];
        bgCtx.globalAlpha = p.life;
        bgCtx.fillStyle = p.color;
        bgCtx.beginPath();
        bgCtx.arc(p.x, p.y, 3, 0, Math.PI*2);
        bgCtx.fill();
        p.x += p.vx; p.y += p.vy; p.vy += 0.05; // gravity
        p.life -= 0.02;
        if(p.life <= 0) particles.splice(i,1);
    }
    bgCtx.globalAlpha = 1;
}

// –†–∏—Å–æ–≤–∞–Ω–∏–µ –±–ª–æ–∫–æ–≤ —Å –Ω–µ–æ–Ω–æ–≤—ã–º —Å–≤–µ—á–µ–Ω–∏–µ–º
function drawBlock(targetCtx, x, y, colorId, size=30) {
    if(!colorId) return;
    const color = colorId === -1 ? '#475569' : COLORS[colorId];
    const px = x * size;
    const py = y * size;

    // –ù–µ–æ–Ω–æ–≤–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ (–¥–æ—Ä–æ–≥–æ, –Ω–æ –∫—Ä–∞—Å–∏–≤–æ)
    targetCtx.shadowBlur = 15;
    targetCtx.shadowColor = color;
    
    // –û—Å–Ω–æ–≤–Ω–æ–π –±–ª–æ–∫
    targetCtx.fillStyle = color;
    targetCtx.fillRect(px + 2, py + 2, size - 4, size - 4);

    // –°–±—Ä–æ—Å —Ç–µ–Ω–∏
    targetCtx.shadowBlur = 0;
    
    // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –±–ª–∏–∫
    targetCtx.fillStyle = 'rgba(255,255,255,0.2)';
    targetCtx.fillRect(px + 2, py + 2, size - 4, size/2 - 2);
}

/* --- 3. –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê --- */
const CONFIG = {
    cols: 10, rows: 20,
    questions: [
        { q: "–ö–∞–∫ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—Å—è 'Red'?", a: ["–ö—Ä–∞—Å–Ω—ã–π", "–°–∏–Ω–∏–π"], c: 0 },
        { q: "–°—Ç–æ–ª–∏—Ü–∞ –í–µ–ª–∏–∫–æ–±—Ä–∏—Ç–∞–Ω–∏–∏?", a: ["–õ–æ–Ω–¥–æ–Ω", "–ü–∞—Ä–∏–∂", "–ë–µ—Ä–ª–∏–Ω"], c: 0 },
        { q: "2 + 2 * 2 = ?", a: ["8", "6"], c: 1 },
        { q: "–°–ª–æ–≤–æ 'Apple' —ç—Ç–æ:", a: ["–Ø–±–ª–æ–∫–æ", "–ì—Ä—É—à–∞", "–ê–ø–µ–ª—å—Å–∏–Ω"], c: 0 }
    ]
};

let arena = createMatrix(10, 20);
let player = { pos: {x:0, y:0}, matrix: null, score: 0 };
let nextPiece = null;
let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;
let isPaused = false;
let gameActive = false;
let timerVal = 300;
let timerRef = null;

function createMatrix(w, h) {
    const matrix = [];
    while (h--) matrix.push(new Array(w).fill(0));
    return matrix;
}

function createPiece(type) {
    if (type === 'I') return [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]];
    if (type === 'L') return [[0, 6, 0], [0, 6, 0], [0, 6, 6]];
    if (type === 'J') return [[0, 7, 0], [0, 7, 0], [7, 7, 0]];
    if (type === 'O') return [[4, 4], [4, 4]];
    if (type === 'Z') return [[1, 1, 0], [0, 1, 1], [0, 0, 0]];
    if (type === 'S') return [[0, 2, 2], [2, 2, 0], [0, 0, 0]];
    if (type === 'T') return [[0, 3, 0], [3, 3, 3], [0, 0, 0]];
}

function startGame(mode) {
    document.querySelectorAll('.overlay').forEach(o => o.classList.remove('active'));
    document.getElementById('game-wrapper').classList.remove('shake');
    
    arena = createMatrix(10, 20);
    player.score = 0;
    player.score = 0;
    timerVal = mode === 'timer' ? 300 : -1; 
    
    updateScore();
    nextPiece = createPiece('ILJOTSZ'[Math.random()*7|0]);
    playerReset();
    
    isPaused = false;
    gameActive = true;
    lastTime = 0;
    dropCounter = 0;
    
    if(timerRef) clearInterval(timerRef);
    if(mode === 'timer') {
        timerRef = setInterval(() => {
            if(!isPaused && gameActive) {
                timerVal--;
                updateTimer();
                if(timerVal <= 0) endGame(true);
            }
        }, 1000);
    } else {
        document.getElementById('time-val').innerText = "‚àû";
    }
    
    update();
}

function playerReset() {
    player.matrix = nextPiece;
    nextPiece = createPiece('ILJOTSZ'[Math.random()*7|0]);
    player.pos.y = 0;
    player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
    
    drawNext();
    
    if (collide(arena, player)) {
        endGame(false);
    }
}

function drawNext() {
    nextCtx.clearRect(0, 0, nextCvs.width, nextCvs.height);
    nextPiece.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) drawBlock(nextCtx, x + 1, y + 1, value, 20);
        });
    });
}

function collide(arena, player) {
    const [m, o] = [player.matrix, player.pos];
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                return true;
            }
        }
    }
    return false;
}

function merge(arena, player) {
    player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                arena[y + player.pos.y][x + player.pos.x] = value;
            }
        });
    });
}

function arenaSweep() {
    let rowsToClear = [];
    outer: for (let y = arena.length - 1; y > 0; --y) {
        for (let x = 0; x < arena[y].length; ++x) {
            if (arena[y][x] === 0) continue outer;
        }
        rowsToClear.push(y);
    }
    
    if(rowsToClear.length > 0) {
        isPaused = true;
        showQuiz(rowsToClear);
    }
}

function update(time = 0) {
    if(!gameActive) return;
    
    if(!isPaused) {
        const deltaTime = time - lastTime;
        lastTime = time;
        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
            playerDrop();
        }
    }

    draw();
    requestAnimationFrame(update);
}

function draw() {
    ctx.clearRect(0, 0, cvs.width, cvs.height);
    
    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∞—Ä–µ–Ω—ã
    arena.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) drawBlock(ctx, x, y, value);
        });
    });
    
    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∏–≥—Ä–æ–∫–∞
    if(player.matrix) {
        player.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) drawBlock(ctx, x + player.pos.x, y + player.pos.y, value);
            });
        });
    }
}

function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        SFX.drop();
        playerReset();
        arenaSweep();
        dropCounter = 0;
    }
}

function playerMove(dir) {
    player.pos.x += dir;
    if (collide(arena, player)) {
        player.pos.x -= dir;
    } else {
        SFX.move();
    }
}

function playerRotate() {
    const pos = player.pos.x;
    let offset = 1;
    const matrix = player.matrix;
    // –¢—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ + —Ä–µ–≤–µ—Ä—Å = –ø–æ–≤–æ—Ä–æ—Ç
    player.matrix = matrix[0].map((val, index) => matrix.map(row => row[index]).reverse());
    
    while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.matrix[0].length) {
            player.matrix = matrix; // –í–æ–∑–≤—Ä–∞—Ç –µ—Å–ª–∏ –Ω–µ–ª—å–∑—è –ø–æ–≤–µ—Ä–Ω—É—Ç—å
            player.pos.x = pos;
            return;
        }
    }
    SFX.rotate();
}

/* --- 4. UI –ò –ö–í–ò–ó --- */

function showQuiz(rows) {
    const q = CONFIG.questions[Math.floor(Math.random() * CONFIG.questions.length)];
    const overlay = document.getElementById('quiz-overlay');
    const container = document.getElementById('q-options');
    
    document.getElementById('q-text').innerText = q.q;
    container.innerHTML = '';
    
    q.a.forEach((ans, idx) => {
        const div = document.createElement('div');
        div.className = 'quiz-opt';
        div.innerText = ans;
        div.onclick = () => handleAnswer(idx === q.c, rows);
        container.appendChild(div);
    });
    
    overlay.classList.add('active');
}

function handleAnswer(isCorrect, rows) {
    document.getElementById('quiz-overlay').classList.remove('active');
    
    if(isCorrect) {
        SFX.clear();
        // –£–¥–∞–ª—è–µ–º –ª–∏–Ω–∏–∏
        rows.sort((a,b)=>a-b).forEach(y => {
            arena.splice(y, 1);
            arena.unshift(new Array(10).fill(0));
            // –ó–∞–ø—É—Å–∫ —Ñ–µ–π–µ—Ä–≤–µ—Ä–∫–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ
            createFirework(window.innerWidth/2, window.innerHeight/2, '#38bdf8');
        });
        
        // –ò—Å–ø—Ä–∞–≤–ª—è–µ–º —Å–µ—Ä—ã–µ –±–ª–æ–∫–∏ (–ª–µ—á–µ–Ω–∏–µ)
        for(let y=0; y<20; y++) {
            for(let x=0; x<10; x++) {
                if(arena[y][x] === -1) arena[y][x] = 0;
            }
        }
        
        player.score += rows.length * 100;
        updateScore();
    } else {
        SFX.error();
        // –®–µ–π–∫ —ç—Ñ—Ñ–µ–∫—Ç
        const wrapper = document.getElementById('game-wrapper');
        wrapper.classList.remove('shake');
        void wrapper.offsetWidth; // trigger reflow
        wrapper.classList.add('shake');
        
        // –ü—Ä–µ–≤—Ä–∞—â–∞–µ–º –≤ –∫–∞–º–µ–Ω—å (-1)
        rows.forEach(y => {
            for(let x=0; x<10; x++) arena[y][x] = -1;
        });
    }
    
    isPaused = false;
}

function updateScore() {
    document.getElementById('score-val').innerText = player.score;
}

function updateTimer() {
    if(timerVal < 0) return;
    const m = Math.floor(timerVal / 60);
    const s = timerVal % 60;
    document.getElementById('time-val').innerText = `${m}:${s<10?'0':''}${s}`;
}

function endGame(win, manual=false) {
    gameActive = false;
    clearInterval(timerRef);
    
    if(manual) {
        resetToMenu();
        return;
    }
    
    const overlay = document.getElementById('result-overlay');
    const title = document.getElementById('res-title');
    const desc = document.getElementById('res-desc');
    
    document.getElementById('res-score').innerText = player.score;
    overlay.classList.add('active');
    
    if(win) {
        title.innerText = "–ü–û–ë–ï–î–ê! üéâ";
        title.style.color = "#10b981";
        desc.innerText = "–í—ã —Å–ø—Ä–∞–≤–∏–ª–∏—Å—å —Å –∑–∞–¥–∞–Ω–∏–µ–º!";
        SFX.win();
        // –ú–Ω–æ–≥–æ —Ñ–µ–π–µ—Ä–≤–µ—Ä–∫–æ–≤
        let fw = setInterval(() => {
            if(!overlay.classList.contains('active')) clearInterval(fw);
            createFirework(
                Math.random()*window.innerWidth, 
                Math.random()*window.innerHeight, 
                COLORS[Math.floor(Math.random()*7)+1]
            );
        }, 300);
    } else {
        title.innerText = "GAME OVER";
        title.style.color = "#f43f5e";
        desc.innerText = "–ü–æ–ª–µ –ø–µ—Ä–µ–ø–æ–ª–Ω–∏–ª–æ—Å—å";
        SFX.error();
    }
}

function resetToMenu() {
    gameActive = false;
    isPaused = true;
    clearInterval(timerRef);
    document.querySelectorAll('.overlay').forEach(o => o.classList.remove('active'));
    document.getElementById('menu-overlay').classList.add('active');
}

// –í–≤–æ–¥
function input(key) {
    if(!gameActive || isPaused) return;
    if(key === 37) playerMove(-1);
    else if(key === 39) playerMove(1);
    else if(key === 40) playerDrop();
    else if(key === 38) playerRotate();
}

document.addEventListener('keydown', event => {
    input(event.keyCode);
});

</script>
</body>
</html>
